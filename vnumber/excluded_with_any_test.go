// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package vnumber

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/SladeThe/yav"
)

func TestExcludedWithAnyInt(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      int
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyInt()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyInt8(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      int8
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyInt8()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyInt16(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      int16
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyInt16()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyInt32(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      int32
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyInt32()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyInt64(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      int64
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyInt64()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyUint(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      uint
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyUint()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyUint8(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      uint8
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyUint8()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyUint16(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      uint16
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyUint16()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyUint32(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      uint32
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyUint32()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyUint64(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      uint64
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyUint64()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyFloat32(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      float32
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyFloat32()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}

func TestExcludedWithAnyFloat64(t *testing.T) {
	type args struct {
		parameters []int
		name       string
		value      float64
	}

	type want struct {
		stop bool
		err  error
	}

	test := func(a args, w want) func(t *testing.T) {
		return func(t *testing.T) {
			accumulator := ExcludedWithAnyFloat64()

			for _, parameter := range a.parameters {
				accumulator = accumulator.Int(parameter)
			}

			stop, err := accumulator.Names("pp")(a.name, a.value)
			assert.Equalf(t, w.stop, stop, "invalid stop: want = %v, got = %v", w.stop, stop)
			assert.Truef(t, reflect.DeepEqual(w.err, err), "invalid error: want = %v, got = %v", w.err, err)
		}
	}

	tests := []struct {
		name string
		args args
		want want
	}{{
		name: "not empty excluded",
		args: args{
			parameters: []int{-1, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: true,
			err: yav.Error{
				CheckName: yav.CheckNameExcludedWithAny,
				Parameter: "pp",
				ValueName: "v",
			},
		},
	}, {
		name: "not empty not excluded",
		args: args{
			parameters: []int{0, 0},
			name:       "v",
			value:      1,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}, {
		name: "empty",
		args: args{
			parameters: []int{1},
			name:       "v",
			value:      0,
		},
		want: want{
			stop: false,
			err:  nil,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, test(tt.args, tt.want))
	}
}
